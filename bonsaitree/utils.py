from typing import Any, DefaultDict, Dict, FrozenSet, List, Set, Tuple

import os
from collections import defaultdict

from .ibd_tools import seg_ends_phys_to_gen


def transform_segment_lists_to_ibd_summaries(
    segments: List[List[Any]],
) -> Dict[FrozenSet[int], Dict[str, Any]]:
    """
    Converts a list of ibd_segment lists to a dict of ibd_summaries

    Args:
        segments: List of IBD segments to generate summary statistics for.
            Has the following format:
            [[id1, id2, chromosome, phys_start, phys_end, is_full_ibd, seg_cm]...]
    """

    ibd_stats: DefaultDict[FrozenSet[int], Dict[str, Any]] = defaultdict(
        lambda: {"total_half": 0, "total_full": 0, "num_half": 0, "max_seg_cm": 0}
    )

    observed_segs: Set[Tuple[int, int, int, int, int, int, int]] = set()
    for s in segments:
        id1, id2, chromosome, start, end, is_full_ibd, seg_cm = s
        seg = (id1, id2, chromosome, start, end, is_full_ibd, seg_cm)
        rev_seg = (id2, id1, chromosome, start, end, is_full_ibd, seg_cm)
        if seg in observed_segs or rev_seg in observed_segs:
            raise ValueError("Duplicate IBD Segment data")
        observed_segs.add(seg)
        observed_segs.add(rev_seg)

        # get segment lengths from map interpolator
        # rather than seg_cm in case user's map is
        # different from the Bonsai map
        start_genet, end_genet = seg_ends_phys_to_gen(
            start_phys = start, 
            end_phys = end,
            chrom = chromosome,
        )

        genet_seg_cm = end_genet - start_genet

        key = frozenset([id1, id2])
        ibd_stats[key]["total_half"] += genet_seg_cm if not is_full_ibd else 0
        ibd_stats[key]["total_full"] += genet_seg_cm if is_full_ibd else 0
        ibd_stats[key]["num_half"] += int(not is_full_ibd)
        ibd_stats[key]["max_seg_cm"] = max(ibd_stats[key]["max_seg_cm"], genet_seg_cm)

    return ibd_stats


def transform_segment_dicts_to_ibd_summaries(
    segments: List[Dict[str, Any]]
) -> Dict[FrozenSet[int], Dict[str, Any]]:
    """
    Converts a list of ibd_segment data to a dict of ibd_summaries

    Args:
        segments: List of IBD segments to generate summary statistics for.
        Has the following format: {
            genotype_id_1: int,
            genotype_id_2: int,
            chromosome: str,
            start: int,
            end: int,
            is_full_ibd: bool,
            seg_cm: float
        }
    """

    ibd_stats: DefaultDict[FrozenSet[int], Dict[str, Any]] = defaultdict(
        lambda: {"total_half": 0, "total_full": 0, "num_half": 0, "max_seg_cm": 0}
    )

    observed_pairs: Set[Tuple[int, int]] = set()
    for s in segments:
        if (s["genotype_id_2"], s["genotype_id_1"]) in observed_pairs:
            raise ValueError("Duplicate IBD Segment data")
        observed_pairs.add((s["genotype_id_1"], s["genotype_id_2"]))

        key = frozenset([s["genotype_id_1"], s["genotype_id_2"]])
        ibd_stats[key]["total_half"] += s["seg_cm"] if not s["is_full_ibd"] else 0
        ibd_stats[key]["total_full"] += s["seg_cm"] if s["is_full_ibd"] else 0
        ibd_stats[key]["num_half"] += int(not s["is_full_ibd"])
        ibd_stats[key]["max_seg_cm"] = max(ibd_stats[key]["max_seg_cm"], s["seg_cm"])

    return ibd_stats


def read_ibis_ibd(
    ibis_dir_path: str,
):
    """
    Read Ibis segments for all chromosomes and convert them to Bonsai format.

    Args:
        ibis_dir_path: Path to directory containing .seg files generated by IBIS
                       for each chromosome.
    """

    seg_file_list = [
        f
        for f in os.listdir(ibis_dir_path)
        if f.endswith('.seg')
    ]

    ibd_seg_list = []
    for seg_file in seg_file_list:
        file_path = os.path.join(ibis_dir_path, seg_file)
        raw_ibis_segs = open(file_path).readlines()
        chrom_ibd_seg_list = ibis_to_ibd_seg_list(
            raw_ibis_segs = raw_ibis_segs,
        )
        ibd_seg_list += chrom_ibd_seg_list

    return ibd_seg_list


def convert_phys_to_gen_seg_positions(
    ibd_seg_list : List[List[Any]],
) -> List[List[Any]]:
    """
    Translate physical positions from IBIS into genetic
    positions consistent with the genetic map Bonsai was
    trained on.

    Args:
        ibd_seg_list : list of IBD segments created by ibis_to_ibd_seg_list()
                       of the form [[id1, id2, chrom, phys_start, phys_end, is_full, gen_seg_len],...]
                       

    Returns:
        ibd_seg_list : of the form
                       [[id1, id2, chrom, gen_start, gen_end, is_full, gen_seg_len],...]
    """

    new_ibd_seg_list = []
    for id1, id2, chrom, phys_start, phys_end, is_full, gen_seg_len in ibd_seg_list:

        # map physical positions to genetic positions using
        # the map 23andMe was trained on
        gen_start, gen_end = seg_ends_phys_to_gen(
            start_phys = phys_start, 
            end_phys = phys_end,
            chrom = chrom,
        )

        gen_seg_len = gen_end - gen_start

        new_seg = (id1, id2, chrom, float(gen_start), float(gen_end), is_full, float(gen_seg_len))

        new_ibd_seg_list.append(new_seg)

    return new_ibd_seg_list


def ibis_to_ibd_seg_list(
    raw_ibis_segs: List[str],
) -> List[List[Any]]:
    """
    Converts the output in a .seg file from IBIS (Seidman et al, 2020) to
    segments that can be input to Bonsai. Specifically, creates the "IBD1 or IBD2"
    class of segments by merging IBD1 and IBD2 segments

    Args:
        raw_ibis_segs: lines from the ibis output file for a given chromosome.
    """

    raw_ibis_segs = [
        d.split()
        for d in raw_ibis_segs
    ]

    # sort ids so that we can put all segs between the same two people
    # into the same contiguous clump
    raw_ibis_segs = [
        [*sorted(seg[:2])] + [*seg[2:]]
        for seg in raw_ibis_segs
    ]

    # sort by id1, i2, chrom, gen_start, gen_end
    raw_ibis_segs = sorted(
        raw_ibis_segs, 
        key=lambda x: (x[0], x[1], x[2], float(x[6]), float(x[7]))
    )

    half_seg_list = [[None] * 9]
    full_seg_list = [[None] * 9]
    for seg in raw_ibis_segs:
        (
            id1, 
            id2, 
            chrom, 
            phys_start, 
            phys_end, 
            ibd_type, 
            gen_start, 
            gen_end, 
            gen_seg_len, 
            num_snps, 
            err_ct, 
            err_density,
        ) = seg

        id1 = int(id1.split(':')[1])
        id2 = int(id2.split(':')[1])
        phys_start = float(phys_start)
        phys_end = float(phys_end)
        gen_start = float(gen_start)
        gen_end = float(gen_end)
        gen_seg_len = float(gen_seg_len)

        # convert 'IBDX' text string to boolean is_full
        is_full = False
        if ibd_type == 'IBD2':
            is_full = True

        # set seg info
        seg_info = [
            id1, 
            id2, 
            chrom, 
            phys_start, 
            phys_end, 
            gen_start, 
            gen_end, 
            is_full, 
            gen_seg_len,
        ]

        # either merge seg with previous half IBD segment or record a new seg
        last_half_seg_info = half_seg_list[-1]
        (
            prev_id1, 
            prev_id2, 
            prev_chrom, 
            prev_phys_start, 
            prev_phys_end, 
            prev_gen_start, 
            prev_gen_end, 
            prev_is_full, 
            prev_gen_seg_len,
        ) = last_half_seg_info

        if id1 == prev_id1 and id2 == prev_id2 and chrom == prev_chrom and (prev_gen_end >= gen_start):
            new_phys_end = max(prev_phys_end, phys_end)
            new_gen_end = max(prev_gen_end, gen_end)
            seg_len_cm = new_gen_end - prev_gen_start
            half_seg_list[-1][4] = new_phys_end
            half_seg_list[-1][6] = new_gen_end
            half_seg_list[-1][8] = seg_len_cm
        else:
            half_seg_list.append(seg_info)

        # either merge seg with previous full IBD segment or record a new seg
        if is_full:
            last_full_seg_info = full_seg_list[-1]
            (
                prev_id1, 
                prev_id2, 
                prev_chrom, 
                prev_phys_start, 
                prev_phys_end, 
                prev_gen_start, 
                prev_gen_end, 
                prev_is_full, 
                prev_gen_seg_len,
            ) = last_full_seg_info
            
            if id1 == prev_id1 and id2 == prev_id2 and chrom == prev_chrom and (prev_gen_end >= gen_start):
                new_phys_end = max(prev_phys_end, phys_end)
                new_gen_end = max(prev_gen_end, gen_end)
                seg_len_cm = new_gen_end - prev_gen_start
                full_seg_list[-1][4] = new_phys_end
                full_seg_list[-1][6] = new_gen_end
                full_seg_list[-1][8] = seg_len_cm
            else:
                full_seg_list.append(seg_info)

    # strip off "None" tuple from each list
    half_seg_list = half_seg_list[1:]
    full_seg_list = full_seg_list[1:]

    # add segments to list
    ibd_seg_list = []
    for seg_info in half_seg_list:
        (
            id1,
            id2,
            chrom,
            phys_start,
            phys_end,
            gen_start,
            gen_end,
            is_full,
            gen_seg_len,
        ) = seg_info
        is_full = False
        seg = (id1, id2, chrom, phys_start, phys_end, is_full, gen_seg_len)
        ibd_seg_list.append(seg)
    for seg_info in full_seg_list:
        (
            id1,
            id2,
            chrom,
            phys_start,
            phys_end,
            gen_start,
            gen_end,
            is_full,
            gen_seg_len,
        ) = seg_info
        is_full = True
        seg = (id1, id2, chrom, phys_start, phys_end, is_full, gen_seg_len)
        ibd_seg_list.append(seg)

    return ibd_seg_list